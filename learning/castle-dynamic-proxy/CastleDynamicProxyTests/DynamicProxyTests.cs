using Castle.DynamicProxy;
using CastleDynamicProxyTests.Exceptions;
using CastleDynamicProxyTests.Features;
using CastleDynamicProxyTests.Interceptors;

namespace CastleDynamicProxyTests;

public class DynamicProxyTests
{
    [Fact]
    public void IsFreezable_should_be_false_for_objects_created_with_ctor()
    {
        var nonFreezablePet = new Pet();
        Assert.False(Freezable.IsFreezable(nonFreezablePet));
    }

    [Fact]
    public void IsFreezable_should_be_true_for_objects_created_with_MakeFreezable()
    {
        var freezablePet = Freezable.MakeFreezable<Pet>();
        Assert.True(Freezable.IsFreezable(freezablePet));
    }

    [Fact]
    public void Freezable_should_work_normally()
    {
        var pet = Freezable.MakeFreezable<Pet>();
        pet.Age = 3;
        pet.Deceased = true;
        pet.Name = "Rex";
        pet.Age += pet.Name.Length;
        Assert.NotNull(pet.ToString());
    }

    [Fact]
    public void Frozen_object_should_throw_ObjectFrozenException_when_trying_to_set_a_property()
    {
        var pet = Freezable.MakeFreezable<Pet>();
        pet.Age = 3;

        Freezable.Freeze(pet);

        Action act = () => pet.Name = "This should throw";
        act.Should().Throw<ObjectFrozenException>();
    }

    [Fact]
    public void Frozen_object_should_not_throw_when_trying_to_read_it()
    {
        var pet = Freezable.MakeFreezable<Pet>();
        pet.Age = 3;

        Freezable.Freeze(pet);

        var age = pet.Age;
        var name = pet.Name;
        var deceased = pet.Deceased;
        var str = pet.ToString();
    }

    [Fact]
    public void Freeze_nonFreezable_object_should_throw_NotFreezableObjectException()
    {
        var rex = new Pet();
        Action action = () => Freezable.Freeze(rex);
        action.Should().Throw<NotFreezableObjectException>();
    }

    [Fact]
    public void Freezable_should_intercept_property_getters()
    {
        var pet = Freezable.MakeFreezable<Pet>();
        Freezable.Freeze(pet);
        var notUsed = pet.Age; //should intercept
        int logsCount = GetInterceptedMethodsCountFor<CallLoggingInterceptor>(pet);
        int freezeCount = GetInterceptedMethodsCountFor<FreezableInterceptor>(pet);
        logsCount.Should().Be(1);
        freezeCount.Should().Be(0);
    }

    [Fact]
    public void DynProxyGetTarget_should_return_proxy_itself()
    {
        var pet = Freezable.MakeFreezable<Pet>();
        // each proxy generated by Castle Dynamic Proxy framework
        // implements an IProxyTargetAccessor interface
        var hack = pet as IProxyTargetAccessor;
        hack.Should().NotBeNull();
        hack!.DynProxyGetTarget().Should().Be(pet);
    }

    [Fact]
    public void Freezable_should_not_hold_any_reference_to_created_objects()
    {
        var fromScope = (Func<WeakReference> getter) => getter();

        var petWeakReference = fromScope(() =>
        {
            var pet = Freezable.MakeFreezable<Pet>();
            var wr = new WeakReference(pet, false);
            pet = null;
            return wr;

        });
        GC.Collect();
        petWeakReference.IsAlive.Should().BeFalse(); // Object should have been collected
    }

    [Fact]
    public void Freezable_should_log_getters_and_setters()
    {
        var pet = Freezable.MakeFreezable<Pet>();
        pet.Age = 4;
        var age = pet.Age;
        int logsCount = GetInterceptedMethodsCountFor<CallLoggingInterceptor>(pet);
        int freezeCount = GetInterceptedMethodsCountFor<FreezableInterceptor>(pet);
        logsCount.Should().Be(2);
        freezeCount.Should().Be(1);
    }

    [Fact]
    public void Freezable_should_not_intercept_methods()
    {
        var pet = Freezable.MakeFreezable<Pet>();
        pet.ToString(); // can be intercepted because it is overriden
        int logsCount = GetInterceptedMethodsCountFor<CallLoggingInterceptor>(pet);
        int freezeCount = GetInterceptedMethodsCountFor<FreezableInterceptor>(pet);
        // base implementation of ToString calls each property getter, that we intercept
        // so there will be 3 calls if method is not intercepter, otherwise 4.
        logsCount.Should().Be(3);
        freezeCount.Should().Be(0);
    }

    private int GetInterceptedMethodsCountFor<T>(object freezable) where T : IHasCount
    {
        Assert.True(Freezable.IsFreezable(freezable));

        var hack = freezable as IProxyTargetAccessor;
        Assert.NotNull(hack);
        var interceptor = (T)hack
            .GetInterceptors()
            .Where(i => i is T )
            .Single();
        interceptor.Should().NotBeNull();
        return interceptor!.Count;
    }
}